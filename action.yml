name: Run Script Kaggle
author: Kevin Kibe
branding:
  icon: upload
  color: green
description: Run any Python/R on Kaggle as tests/code execution.

inputs:
  username:
    description: kaggle username
    required: true
  key:
    description: kaggle token
    required: true
  title:
    description: The title of the kernel
    required: true
  custom_script:
    description: Custom script content to run in the notebook
    required: true
    default: "print('Now what')"
  enable_gpu:
    description: Whether or not kernel should run on a GPU.
    required: false
    default: "false"
  enable_tpu:
    description: Whether or not kernel should run on a TPU.
    required: false
    default: "false"
  enable_internet:
    description: Whether or not kernel should be able to access the internet.
    required: false
    default: "true"
  dataset_sources:
    description: A list of data sources that kernel should use. Each dataset is specified as {username}/{dataset-slug}.
    required: false
    default: ""
  competition_sources:
    description: A list of competition data sources that kernel should use.
    required: false
    default: ""
  kernel_sources:
    description: A list of kernel data sources that kernel should use. Each dataset is specified as {username}/{kernel-slug}.
    required: false
    default: ""

outputs:
  automatic_releases_tag:
    description: The release tag this action just processed
    value: ""
  upload_url:
    description: The URL for uploading additional assets to the release
    value: ""

runs:
  using: composite
  steps:
    - name: Install kaggle CLI tools
      shell: bash
      run: |
        python -m pip install --upgrade kaggle --user

    - name: Setup kaggle.json
      shell: bash
      run: |
        log_message() {
            echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
        }
        
        log_message "Creating the Kaggle configuration directory at ~/.kaggle..."
        mkdir -p ~/.kaggle
        
        log_message "Writing credentials to kaggle.json..."
        
        if [ -z "${{ inputs.username }}" ]; then
            echo "::error::Username is required but was empty"
            exit 1
        fi
        
        if [ -z "${{ inputs.key }}" ]; then
            echo "::error::Kaggle key is required but was empty"
            exit 1
        fi
        
        echo "{\"username\":\"${{ inputs.username }}\",\"key\":\"${{ inputs.key }}\"}" > ~/.kaggle/kaggle.json
        
        log_message "Setting appropriate permissions for kaggle.json (read and write for user only)..."
        chmod 600 ~/.kaggle/kaggle.json
        
        log_message "Kaggle configuration setup complete."

    - name: Set up Notebook Kernel
      shell: bash
      run: |
        log_message() {
            echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
        }
        
        log_message "Setting up the notebook for Kaggle execution..."
        
        action_path=$(realpath "${{ github.action_path }}")
        OUTPUT_NOTEBOOK="$action_path/script.ipynb"
        log_message "Notebook will be saved as: $OUTPUT_NOTEBOOK"
        
        REPO_URL=$(git config --get remote.origin.url)        
        REPO_NAME=$(basename "$REPO_URL" .git)
        BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
        log_message "Cloning repository URL: $REPO_URL on branch: $BRANCH_NAME"
        
        CUSTOM_SCRIPT="${{ inputs.custom_script }}"
        log_message "Adding custom script to notebook: $CUSTOM_SCRIPT"
        
        dependencies="!cd /kaggle/working/$REPO_NAME && pip install -r requirements.txt"
        
        cat <<EOM > "$OUTPUT_NOTEBOOK"
        {
          "cells": [
            {
              "cell_type": "code",
              "execution_count": null,
              "metadata": {},
              "outputs": [],
              "source": [
                "!git clone --branch $BRANCH_NAME $REPO_URL.git"
              ]
            },
            {
              "cell_type": "code",
              "execution_count": null,
              "metadata": {},
              "outputs": [],
              "source": [
                "$dependencies"
              ]
            },
            {
              "cell_type": "code",
              "execution_count": null,
              "metadata": {},
              "outputs": [],
              "source": [
                "$CUSTOM_SCRIPT"
              ]
            }
          ],
          "metadata": {
            "kernelspec": {
              "display_name": "Python 3",
              "language": "python",
              "name": "python3"
            },
            "language_info": {
              "name": "python",
              "version": "3.8"
            }
          },
          "nbformat": 4,
          "nbformat_minor": 2
        }
        EOM
        
        log_message "Notebook '$OUTPUT_NOTEBOOK' created successfully"


    - name: Setup test
      shell: bash
      run: |
        log_message() {
            echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
        }
        
        action_path=$(realpath "${{ github.action_path }}")
        OUTPUT_NOTEBOOK="$action_path/script.ipynb"
        
        log_message "Navigating to the action path: '$action_path'"
        cd "$action_path"
        
        log_message "Initializing Kaggle kernel metadata..."
        kaggle kernels init -p "$action_path"
        
        json_path="$action_path/kernel-metadata.json"
        log_message "Kernel metadata template created at: $json_path"
        
        metadata=$(jq -r '. | tojson' < "$json_path")
        
        title="${{ inputs.title }}"  
        formatted_title=$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/ /_/g')
        
        log_message "Updating metadata with specified inputs..."
        metadata=$(echo "$metadata" | jq --arg title "${{ inputs.title }}" \
                                 --arg code_file "$OUTPUT_NOTEBOOK" \
                                 --argjson enable_gpu "${{ inputs.enable_gpu }}" \
                                 --argjson enable_internet "${{ inputs.enable_internet }}" \
                                 --argjson enable_internet "${{ inputs.enable_tpu }}" \
                                 '. |
                                   .id = (.id | split("/")[0]) + "/" + $title |
                                   .title = $title |
                                   .code_file = $code_file |
                                   .language = "python" |
                                   .kernel_type = "notebook" |
                                   .enable_gpu = $enable_gpu |
                                   .enable_internet = $enable_internet' |
                                   .enable_tpu = $enable_tpu')
        
        echo "Saving updated metadata back to $json_path"
        echo "$metadata" | jq '.' > "$json_path"
        
        echo "Final kernel metadata content:"
        cat "$json_path"  
        
        log_message "Pushing Kaggle kernel with updated metadata..."
        kaggle kernels push -p "$action_path"
        
        log_message "Kaggle kernel setup and push completed successfully."
    

    - name: Check status
      shell: bash
      run: |
        
        # Set default timeout and check interval values
        MAX_WAIT_TIME=3600  # 1 hour timeout
        CHECK_INTERVAL=10   # Check every 10 seconds
        TIME_ELAPSED=0
        
        # Set location to the action path
        echo "Setting action path to: '$action_path'"
        action_path=$(realpath "${{ github.action_path }}")
        echo "Resolved action path: '$action_path'"
        cd "$action_path"
        
        # Get username and kernel title from inputs
        username="${{ inputs.username }}"
        kernel_title="${{ inputs.title }}"
        
        # Validate inputs
        if [ -z "$username" ]; then
            echo "::error::Username is required but was empty"
            exit 1
        fi
        
        if [ -z "$kernel_title" ]; then
            echo "::error::Kernel title is required but was empty"
            exit 1
        fi
        
        # Construct the full kernel name
        kernel_name="$username/$kernel_title"
        echo "Checking status for Kaggle kernel: '$kernel_name'"
        
        # Function to check kernel status with better error handling
        check_kernel_status() {
            # Verify Kaggle CLI configuration
            if ! kaggle --version &>/dev/null; then
                echo "::error::Kaggle CLI not properly installed or configured"
                return 1
            fi
        
            # Check if KAGGLE_KEY is set
            if [ -z "${{ inputs.key }}" ]; then
                echo "::error::Kaggle API key not properly configured. Please check KAGGLE_KEY"
                return 1
            fi
        
            # Attempt to get kernel status with error capture
            local status_output
            if ! status_output=$(kaggle kernels status "$kernel_name" 2>&1); then
                if [[ "$status_output" == *"401"* ]] || [[ "$status_output" == *"authentication"* ]]; then
                    echo "::error::Authentication failed. Please verify your Kaggle credentials"
                    return 1
                fi
                if [[ "$status_output" == *"404"* ]] || [[ "$status_output" == *"not found"* ]]; then
                    echo "::error::Kernel not found: $kernel_name"
                    return 1
                fi
                echo "::warning::Failed to get kernel status: $status_output"
                return 1
            fi
            echo "$status_output"
            return 0
        }
        
        # Function to log with timestamp
        log_message() {
            echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
        }
        
        # Initial status check
        log_message "Verifying Kaggle configuration and kernel access..."
        if ! check_kernel_status; then
            log_message "::error::Initial kernel status check failed"
            exit 1
        fi
        
        # Main loop to check kernel status
        while [ $TIME_ELAPSED -lt $MAX_WAIT_TIME ]; do
            log_message "Retrieving kernel status..."
            status=$(check_kernel_status)
            
            # Check if status command failed
            if [ $? -ne 0 ]; then
                log_message "::error::Failed to retrieve kernel status. Retrying in ${CHECK_INTERVAL} seconds..."
                sleep $CHECK_INTERVAL
                TIME_ELAPSED=$((TIME_ELAPSED + CHECK_INTERVAL))
                continue
            fi
            
            log_message "Current kernel status: $status"
        
            # Check for different status conditions
            if [[ "$status" == *"error"* ]]; then
                log_message "::error::FAIL: Kernel execution failed with error"
                # Try to get logs before exiting
                log_message "::group::Error Logs"
                kaggle kernels logs "$kernel_name" 2>&1 || echo "Failed to retrieve logs"
                log_message "::endgroup::"
                exit 1
            elif [[ "$status" == *"cancel"* ]]; then
                log_message "::error::FAIL: Kernel execution was canceled"
                exit 1
            elif [[ "$status" == *"complete"* ]]; then
                log_message "SUCCESS: Kernel execution completed successfully!"
                exit 0
            elif [[ "$status" == *"running"* ]]; then
                log_message "Kernel is still running..."
            else
                log_message "WARNING: Unexpected status: '$status'"
            fi
        
            # Update elapsed time and check timeout
            TIME_ELAPSED=$((TIME_ELAPSED + CHECK_INTERVAL))
            REMAINING_TIME=$((MAX_WAIT_TIME - TIME_ELAPSED))
            
            if [ $REMAINING_TIME -le 0 ]; then
                log_message "::error::FAIL: Timeout reached after ${MAX_WAIT_TIME} seconds"
                break
            fi
        
            log_message "Next check in ${CHECK_INTERVAL} seconds (${REMAINING_TIME} seconds remaining)..."
            sleep $CHECK_INTERVAL
        done
        
        # Handle timeout
        if [ $TIME_ELAPSED -ge $MAX_WAIT_TIME ]; then
            log_message "::error::FAIL: Execution timed out after ${MAX_WAIT_TIME} seconds"
            log_message "::group::Final Status and Logs"
            kaggle kernels status "$kernel_name" 2>&1 || echo "Failed to get final status"
            echo "---"
            kaggle kernels logs "$kernel_name" 2>&1 || echo "Failed to retrieve logs"
            log_message "::endgroup::"
            exit 1
        fi
   
