name: Run Script Kaggle
author: Kevin Kibe
branding:
  icon: upload
  color: green
description: Run any Python/R on Kaggle as tests/code execution.

inputs:
  username:
    description: kaggle username
    required: true
  key:
    description: kaggle token
    required: true
  title:
    description: The title of the kernel
    required: true
  custom_script:
    description: Custom script content to run in the notebook
    required: true
    default: "print('Now what')"
  enable_gpu:
    description: Whether or not kernel should run on a GPU.
    required: false
    default: "false"
  enable_internet:
    description: Whether or not kernel should be able to access the internet.
    required: false
    default: "true"
  dataset_sources:
    description: A list of data sources that kernel should use. Each dataset is specified as {username}/{dataset-slug}.
    required: false
    default: ""
  competition_sources:
    description: A list of competition data sources that kernel should use.
    required: false
    default: ""
  kernel_sources:
    description: A list of kernel data sources that kernel should use. Each dataset is specified as {username}/{kernel-slug}.
    required: false
    default: ""

outputs:
  automatic_releases_tag:
    description: The release tag this action just processed
    value: ""
  upload_url:
    description: The URL for uploading additional assets to the release
    value: ""

runs:
  using: composite
  steps:
    - name: Install kaggle CLI tools
      shell: bash
      run: |
        python -m pip install --upgrade kaggle --user

    - name: Setup kaggle.json
      shell: bash
      run: |
        echo "Creating the Kaggle configuration directory at ~/.kaggle..."
        mkdir -p ~/.kaggle
        
        echo "Writing credentials to kaggle.json..."
        echo "{\"username\":\"${{ inputs.username }}\",\"key\":\"${{ inputs.key }}\"}" > ~/.kaggle/kaggle.json
        
        echo "Setting appropriate permissions for kaggle.json (read and write for user only)..."
        chmod 600 ~/.kaggle/kaggle.json
        
        echo "Kaggle configuration setup complete."

    - name: Set up Notebook Kernel
      shell: bash
      run: |
        echo "Setting up the notebook for Kaggle execution..."
        
        # Define the output notebook and retrieve repository information
        action_path=$(realpath "${{ github.action_path }}")
        OUTPUT_NOTEBOOK="$action_path/project_setup.ipynb"
        echo "Notebook will be saved as: $OUTPUT_NOTEBOOK"
        
        REPO_URL=$(git config --get remote.origin.url)
        echo "Repository URL: $REPO_URL"
        
        REPO_NAME=$(basename "$REPO_URL" .git)
        
        BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
        echo "Current branch: $BRANCH_NAME"
        
        CUSTOM_SCRIPT="${{ inputs.custom_script }}"
        echo "Custom script to be included in the notebook: $CUSTOM_SCRIPT"
        
        # Define the command for installing dependencies within the cloned directory
        dependencies="!cd /kaggle/working/$REPO_NAME && pip install -r requirements.txt"
        
        # Create the Jupyter notebook JSON structure with three cells
        cat <<EOM > "$OUTPUT_NOTEBOOK"
        {
          "cells": [
            {
              "cell_type": "code",
              "execution_count": null,
              "metadata": {},
              "outputs": [],
              "source": [
                "!git clone --branch $BRANCH_NAME $REPO_URL.git"
              ]
            },
            {
              "cell_type": "code",
              "execution_count": null,
              "metadata": {},
              "outputs": [],
              "source": [
                "$dependencies"
              ]
            },
            {
              "cell_type": "code",
              "execution_count": null,
              "metadata": {},
              "outputs": [],
              "source": [
                "$CUSTOM_SCRIPT"
              ]
            }
          ],
          "metadata": {
            "kernelspec": {
              "display_name": "Python 3",
              "language": "python",
              "name": "python3"
            },
            "language_info": {
              "name": "python",
              "version": "3.8"
            }
          },
          "nbformat": 4,
          "nbformat_minor": 2
        }
        EOM
        
        echo "Notebook '$OUTPUT_NOTEBOOK' created successfully"


    - name: Setup test
      shell: bash
      run: |
        action_path=$(realpath "${{ github.action_path }}")
        OUTPUT_NOTEBOOK="$action_path/project_setup.ipynb"
        
        echo "Navigating to the action path: '$action_path'"
        cd "$action_path"
        
        echo "Initializing Kaggle kernel metadata at path: '$action_path'"
        kaggle kernels init -p "$action_path"
        
        json_path="$action_path/kernel-metadata.json"
        echo "Kernel metadata template created at: $json_path"
        
        echo "Loading current metadata for processing..."
        metadata=$(jq -r '. | tojson' < "$json_path")
        
        title="${{ inputs.title }}"  
        formatted_title=$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/ /_/g')
        
        echo "Updating metadata with specified inputs..."
        metadata=$(echo "$metadata" | jq --arg title "${{ inputs.title }}" \
                                         --arg code_file "$OUTPUT_NOTEBOOK" \
                                         --arg enable_gpu "${{ inputs.enable_gpu }}" \
                                         --arg enable_internet "${{ inputs.enable_internet }}" \
                                         '. |
                                           .id = (.id | split("/")[0]) + "/" + $title |
                                           .title = $title |
                                           .code_file = $code_file |
                                           .language = "python" |
                                           .kernel_type = "notebook" |
                                           .enable_gpu = true |
                                           .enable_internet = true')
        
        echo "Saving updated metadata back to $json_path"
        echo "$metadata" | jq '.' > "$json_path"
        
        echo "Final kernel metadata content:"
        cat "$json_path"  
        
        echo "Pushing Kaggle kernel with updated metadata..."
        kaggle kernels push -p "$action_path"
        
        echo "Kaggle kernel setup and push completed successfully."
    

    - name: Check status
      shell: bash
      run: |
        MAX_WAIT_TIME=3600  # 1 hour timeout
        CHECK_INTERVAL=10   # Check every 10 seconds
        TIME_ELAPSED=0
        
        # Set location to the action path
        echo "Setting action path to: '$action_path'"
        action_path=$(realpath "${{ github.action_path }}")
        echo "Resolved action path: '$action_path'"
        cd "$action_path"
        
        # Define the kernel name
        kernel_name="${{ inputs.title }}"
        echo "Checking status for Kaggle kernel: '$kernel_name'"
        
        # Function to check kernel status
        check_kernel_status() {
            kaggle kernels status "$kernel_name" 2>&1
        }
        
        # Function to log with timestamp
        log_message() {
            echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
        }
        
        # Main loop to check kernel status
        while [ $TIME_ELAPSED -lt $MAX_WAIT_TIME ]; do
            log_message "Retrieving kernel status..."
            status=$(check_kernel_status)
            log_message "Current kernel status: $status"
        
            # Check for different status conditions
            if [[ "$status" == *"error"* ]]; then
                log_message "::error::FAIL: Kernel execution failed with error."
                exit 1
            elif [[ "$status" == *"cancel"* ]]; then
                log_message "::error::FAIL: Kernel execution was canceled."
                exit 1
            elif [[ "$status" == *"complete"* ]]; then
                log_message "SUCCESS: Kernel execution completed successfully!"
                exit 0
            elif [[ "$status" == *"running"* ]]; then
                log_message "Kernel is still running..."
            else
                log_message "WARNING: Unexpected status received: $status"
            fi
        
            # Update elapsed time and check timeout
            TIME_ELAPSED=$((TIME_ELAPSED + CHECK_INTERVAL))
            REMAINING_TIME=$((MAX_WAIT_TIME - TIME_ELAPSED))
            
            if [ $REMAINING_TIME -le 0 ]; then
                log_message "::error::FAIL: Timeout reached after ${MAX_WAIT_TIME} seconds"
                break
            fi
        
            log_message "Waiting ${CHECK_INTERVAL} seconds before next check (${REMAINING_TIME} seconds remaining)..."
            sleep $CHECK_INTERVAL
        done
        
        # If we exit the loop without success, it's a timeout
        if [ $TIME_ELAPSED -ge $MAX_WAIT_TIME ]; then
            log_message "::error::FAIL: Execution timed out after ${MAX_WAIT_TIME} seconds"
        
            # Attempt to fetch and display logs
            log_message "::group::Full Kernel Log"
            if [ -f "${kernel_name}.log" ]; then
                cat "${kernel_name}.log"
            else
                log_message "No log file found at ${kernel_name}.log"
                kaggle kernels logs "$kernel_name" 2>&1
            fi
            log_message "::endgroup::"
            exit 1
        fi
   
