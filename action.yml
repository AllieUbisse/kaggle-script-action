name: Run Script Kaggle
author: Kevin Kibe
branding:
  icon: upload
  color: green
description: Run any Python/R on Kaggle as tests/code execution.

inputs:
  username:
    description: kaggle username
    required: true
  key:
    description: kaggle token
    required: true
  title:
    description: The title of the kernel
    required: true
  custom_script:
    description: Custom script content to run in the notebook
    required: true
    default: "print('Now what')"
  enable_gpu:
    description: Whether or not kernel should run on a GPU.
    required: false
    default: "false"
  enable_internet:
    description: Whether or not kernel should be able to access the internet.
    required: false
    default: "false"
  dataset_sources:
    description: A list of data sources that kernel should use. Each dataset is specified as {username}/{dataset-slug}.
    required: false
    default: ""
  competition_sources:
    description: A list of competition data sources that kernel should use.
    required: false
    default: ""
  kernel_sources:
    description: A list of kernel data sources that kernel should use. Each dataset is specified as {username}/{kernel-slug}.
    required: false
    default: ""

outputs:
  automatic_releases_tag:
    description: The release tag this action just processed
    value: ""
  upload_url:
    description: The URL for uploading additional assets to the release
    value: ""

runs:
  using: composite
  steps:
    - name: Install kaggle CLI tools
      shell: bash
      run: |
        python -m pip install --upgrade kaggle --user

    - name: Setup kaggle.json
      shell: bash
      run: |
        echo "Creating the Kaggle configuration directory at ~/.kaggle..."
        mkdir -p ~/.kaggle
        
        echo "Writing credentials to kaggle.json..."
        echo "{\"username\":\"${{ inputs.username }}\",\"key\":\"${{ inputs.key }}\"}" > ~/.kaggle/kaggle.json
        
        echo "Setting appropriate permissions for kaggle.json (read and write for user only)..."
        chmod 600 ~/.kaggle/kaggle.json
        
        echo "Kaggle configuration setup complete."

    - name: Set up Notebook Kernel
      shell: bash
      run: |
        echo "Setting up the notebook for Kaggle execution..."
        
        # Define the output notebook and retrieve repository information
        action_path=$(realpath "${{ github.action_path }}")
        OUTPUT_NOTEBOOK="$action_path/project_setup.ipynb"
        echo "Notebook will be saved as: $OUTPUT_NOTEBOOK"
        
        REPO_URL=$(git config --get remote.origin.url)
        echo "Repository URL: $REPO_URL"
        
        REPO_NAME=$(basename "$REPO_URL" .git)
        
        BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
        echo "Current branch: $BRANCH_NAME"
        
        CUSTOM_SCRIPT="${{ inputs.custom_script }}"
        echo "Custom script to be included in the notebook: $CUSTOM_SCRIPT"
        
        # Define the command for installing dependencies within the cloned directory
        dependencies="!cd /kaggle/working/$REPO_NAME && pip install -r requirements.txt"
        
        # Create the Jupyter notebook JSON structure with three cells
        cat <<EOM > "$OUTPUT_NOTEBOOK"
        {
          "cells": [
            {
              "cell_type": "code",
              "execution_count": null,
              "metadata": {},
              "outputs": [],
              "source": [
                "!git clone --branch $BRANCH_NAME $REPO_URL"
              ]
            },
            {
              "cell_type": "code",
              "execution_count": null,
              "metadata": {},
              "outputs": [],
              "source": [
                "$dependencies"
              ]
            },
            {
              "cell_type": "code",
              "execution_count": null,
              "metadata": {},
              "outputs": [],
              "source": [
                "$CUSTOM_SCRIPT"
              ]
            }
          ],
          "metadata": {
            "kernelspec": {
              "display_name": "Python 3",
              "language": "python",
              "name": "python3"
            },
            "language_info": {
              "name": "python",
              "version": "3.8"
            }
          },
          "nbformat": 4,
          "nbformat_minor": 2
        }
        EOM
        
        echo "Notebook '$OUTPUT_NOTEBOOK' created successfully"


    - name: Setup test
      shell: bash
      run: |
        action_path=$(realpath "${{ github.action_path }}")
        OUTPUT_NOTEBOOK="$action_path/project_setup.ipynb"
        
        echo "Navigating to the action path: '$action_path'"
        cd "$action_path"
        
        echo "Initializing Kaggle kernel metadata at path: '$action_path'"
        kaggle kernels init -p "$action_path"
        
        json_path="$action_path/kernel-metadata.json"
        echo "Kernel metadata template created at: $json_path"
        
        echo "Loading current metadata for processing..."
        metadata=$(jq -r '. | tojson' < "$json_path")
        
        title="${{ inputs.title }}"  
        formatted_title=$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/ /_/g')
        
        echo "Updating metadata with specified inputs..."
        metadata=$(echo "$metadata" | jq --arg title "${{ inputs.title }}" \
                                         --arg id "${{ inputs.username }}/$formatted_title" \
                                            '.id = $id | .title = $title')
                                         --arg code_file "$OUTPUT_NOTEBOOK" \
                                         --arg enable_gpu "${{ inputs.enable_gpu }}" \
                                         --arg enable_internet "${{ inputs.enable_internet }}" \
                                         '. |
                                           .id = (.id | split("/")[0]) + "/" + $title |
                                           .title = $title |
                                           .code_file = $code_file |
                                           .language = "python" |
                                           .kernel_type = "notebook" |
                                           .enable_gpu = ($enable_gpu == "enable") |
                                           .enable_internet = ($enable_internet == "enable")')
        
        echo "Saving updated metadata back to $json_path"
        echo "$metadata" | jq '.' > "$json_path"
        
        echo "Final kernel metadata content:"
        cat "$json_path"  
        
        echo "Pushing Kaggle kernel with updated metadata..."
        kaggle kernels push -p "$action_path"
        
        echo "Kaggle kernel setup and push completed successfully."
    

    - name: Check status
      shell: bash
      run: |
        # Set location to the action path
        echo "Setting action path to: '${{ github.action_path }}'"
        action_path=$(realpath "${{ github.action_path }}")
        echo "Resolved action path: '$action_path'"
        cd "$action_path"
        
        # Define the kernel name
        kernel_name="${{ inputs.title }}"
        echo "Checking status for Kaggle kernel: '$kernel_name'"
        
        # Check kernel status
        while true; do
          echo "Retrieving kernel status..."
          status=$(kaggle kernels status "$kernel_name" 2>&1)
          echo "Current kernel status: $status"
        
          if [[ "$status" == *"error"* ]]; then
            echo "::error::FAIL: Run(s) failed." >&2
            exit 1
          elif [[ "$status" == *"cancel"* ]]; then
            echo "::error::FAIL: Run(s) failed. The Kaggle kernel has been canceled." >&2
            exit 1
          elif [[ "$status" == *"complete"* ]]; then
            echo "SUCCESS: Run successfully completed!" >&2
            break
          else
            echo "Kernel is still running. Rechecking in 3 seconds..."
            sleep 3
          fi
        done
        
        # Output full log on failure
        if [ $? -ne 0 ]; then
          echo "::group::Full log"
          echo "Displaying the full log for kernel '$kernel_name':"
          cat "$kernel_name.log"
          echo "::endgroup::"
          exit 1
        fi
